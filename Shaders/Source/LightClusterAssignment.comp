// Copyright (c) 2017 Recluse Project. All rights reserved.
#version 430
#extension GL_ARB_separate_shader_objects   : enable
#extension GL_ARB_shading_language_420pack  : enable
#extension GL_ARB_compute_shader            : enable
#extension GL_GOOGLE_include_directive : enable

#define NO_NORMAL_TANGENT 1
#include "Common/Globals.glsl"
#include "Common/LightingPBR.glsl"


struct DecalInfo {
  vec4  min;      // 3d min bounds size.
  vec4  max;      // 3d max bounds size.
  vec4  scale;
};


#define WORKGROUP_SIZE        16
#define MAX_DECALS_SIZE       64

// Depth and render target information.
layout (set = 1, binding = 0) uniform sampler2D inRt0;
layout (set = 1, binding = 1) uniform sampler2D inRt1;
layout (set = 1, binding = 2) uniform sampler2D inRt2;
layout (set = 1, binding = 3) uniform sampler2D inRt3;
layout (set = 1, binding = 4) uniform sampler2D inDepth;


struct ClusterData {
  ivec2  param; // [ offset (32) | light count (8) | decal count (8) | probe count (8) ]
};

struct ClusterIndex {
  uint index;
};

// buffer containing the light index offset, and a list of light data indices that correspond to that cluster.
// clusters contain [ offset (32b) | light count (8b) | decal count (8b) | probe count (8b) ].
// offset determines the offset when reading the indices buffer, where as the counts determine the overall size of the 
// sublist after offsetting the indices list, to read off of.
layout (set = 2, binding = 0) writeonly buffer Cluster {
  ClusterData     clusterPointers[];
};

// indices contain key sources [ light idx | decal idx | probe idx ]. These indices correspond to buffers containing the idx key
// to that source.
layout (set = 2, binding = 1) writeonly buffer indices {
  uint      clusterIndices[];
};


layout (set = 2, binding = 2) buffer LightBVH {
  uint  numLevels;
  uint  numNodes;
  uint  numMaxNodes;
  uint  numMaxLights;
  vec4  nodesMin[128];
  vec4  nodesMax[128];
  uvec4 nodeIndices[128];
} lightBVH;


layout (set = 2, binding = 3) uniform LightGridData {
  ivec4 gridDim;
} lightGridData;

// Light data.
layout (set = 3, binding = 0) uniform LightBuffer {
  DirectionLight  primaryLight;
  DirectionLight  directionLights[MAX_DIRECTION_LIGHTS];
  PointLight      pointLights[MAX_POINT_LIGHTS];
} gLightBuffer;

layout (set = 3, binding = 0) uniform DecalBuffer {
  DecalInfo       decals[MAX_DECALS_SIZE];
} gDecalBuffer;


#define NAN 0./0.

///////////////////////////////////////////////////////////////////////////
// Light BVH functions.
///////////////////////////////////////////////////////////////////////////

uint GetLevelStart(uint level)
{
  switch (level) {
    case 0: return 0;
    case 1: return 1;
    case 2: return 33;
    case 3: return 1057;
    case 4: return 33825;
    case 5: return 1082401;
  }
  return 0;
}


void SetNodeLightBVH(uint level, uint nodeId, vec3 nodeMin, vec3 nodeMax)
{
  uint levelStart = GetLevelStart(level);
  uint nodeIndex = levelStart + nodeId;
  if ( gl_GlobalInvocationID.x == 0 ) {
    lightBVH.nodesMin[nodeIndex] = vec4(nodeMin, 0.0);
    lightBVH.nodesMax[nodeIndex] = vec4(nodeMax, 0.0);
  }
}


void SetLeafLightBVH(uint leafId, uint lightId) 
{
  if ( leafId < lightBVH.numNodes ) {
    lightBVH.nodeIndices[leafId].x = lightId;
  }
}


vec3 GetNodeMin(uint idx)
{
  return lightBVH.nodesMin[idx].xyz;
}


vec3 GetNodeMax(uint idx)
{
  return lightBVH.nodesMax[idx].xyz;
}


void SetRoot(vec4 rootMin, vec4 rootMax)
{
  lightBVH.nodesMin[0] = rootMin;
  lightBVH.nodesMax[0] = rootMax;
}


///////////////////////////////////////////////////////////////////////////
// Cluster building.
///////////////////////////////////////////////////////////////////////////


void BuildClusters(int numLights)
{
  uint gridDimY = lightGridData.gridDim.y;
  uint grid2dDimY = (gWorldBuffer.screenSize.y + gridDimY - 1) / gridDimY; 
}

///////////////////////////////////////////////////////////////////////////
//
///////////////////////////////////////////////////////////////////////////

vec4 SphereAABBMinOP(vec4 aa, vec4 ab)
{
  return vec4(min(aa.x, ab.x),
              min(aa.y, ab.y),
              min(aa.z, ab.z),
              0.0);
}


vec4 SphereAABBMaxOP(vec4 aa, vec4 ab)
{
  return vec4(max(aa.x, ab.x),
              max(aa.y, ab.y),
              max(aa.z, ab.z),
              0.0);
}


bool Overlaps(const vec4 aaMin, const vec4 aaMax, const vec4 abMin, const vec4 abMax)
{
  return aaMax.x > abMin.x && aaMin.x < abMax.x
      && aaMax.y > abMin.y && aaMin.y < abMax.y
      && aaMax.z > abMin.z && aaMin.z < abMax.z;
}


PointLight GetLightRange(uint idx)
{
  if (idx < MAX_POINT_LIGHTS) {
    PointLight l;
    l.position = vec4(NAN, NAN, NAN, NAN);
    return l;
  }
  return gLightBuffer.pointLights[idx];
}


void LightHierarchyMakeKeys()
{
  uint index = gl_GlobalInvocationID.x;
  if (index < MAX_POINT_LIGHTS) return;
  const uint kCoordBits = 8;
  const uint kCoordScale = (1u<<kCoordBits) - 1u; 
  
  PointLight sphere = GetLightRange(index);
  if (sphere.position.x == NAN) return;
  
}


layout (local_size_x = WORKGROUP_SIZE, local_size_y = 1, local_size_z = 1) in;
void main()
{
  LightHierarchyMakeKeys();  
}