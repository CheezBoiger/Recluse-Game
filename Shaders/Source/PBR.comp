#version 430
#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#extension GL_ARB_compute_shader : enable
#extension GL_GOOGLE_include_directive : enable

#include "Common/Globals.glsl"
#include "Common/GBufferDefines.glsl"
#include "Common/LightingPBR.glsl"
#include "Common/Shadowing.glsl"

#define MAX_DIRECTION_LIGHTS    4
#define MAX_POINT_LIGHTS        64
#ifndef LOCAL_SIZE
  #if defined(NVIDIA)
   #define LOCAL_SIZE           32
  #elif defined(AMD)
   #define LOCAL_SIZE           64
  #else
   #define LOCAL_SIZE           16
  #endif
#endif

layout (set = 1, binding = 0) uniform sampler2D inRt0;
layout (set = 1, binding = 1) uniform sampler2D inRt1;
layout (set = 1, binding = 2) uniform sampler2D inRt2;
layout (set = 1, binding = 3) uniform sampler2D inRt3;
layout (set = 1, binding = 4) uniform sampler2D inDepth;

layout (set = 2, binding = 0) uniform LightBuffer {
  DirectionLight  primaryLight;
  DirectionLight  directionLights[MAX_DIRECTION_LIGHTS];
  PointLight      pointLights[MAX_POINT_LIGHTS];
} gLightBuffer;

layout (set = 3, binding = 0) uniform DynamicLightSpace {
  LightSpace lightSpace;
} dynamicLightSpace;

layout (set = 3, binding = 1) uniform sampler2D dynamicShadowMap;

layout (set = 4, binding = 0) uniform StaticLightSpace {
  LightSpace lightSpace;
} staticLightSpace;

layout (set = 4, binding = 1) uniform sampler2D staticShadowMap;

struct DiffuseSH {
  vec4 c[9];
};

layout (set = 5, binding = 0) buffer GlobalMapInfo {
  DiffuseSH sh;
} globalMapInfo;
layout (set = 5, binding = 1) uniform samplerCube specMap;
layout (set = 5, binding = 2) uniform sampler2D brdfLut;
#if defined(LOCAL_REFLECTIONS)
layout (set = 5, binding = 3) buffer LocalMapInfo {
  vec4      positions[32];
  vec4      minAABB[32];
  vec4      maxAABB[32];
  DiffuseSH shs[32];
} localMapInfo;
layout (set = 5, binding = 4) uniform samplerCubeArray specMaps;   // Current set enviroment map (radiance).
layout (set = 5, binding = 5) uniform sampler2DArray brdfLuts;    // BRDF lookup tables corresponding to each env map.
#endif

layout (set = 6, binding = 0, rgba8) uniform writeonly image2D outResult;
layout (set = 6, binding = 1, rgba16) uniform writeonly image2D outBright; 

layout (set = 7, binding = 0, rg32ui) uniform readonly uimage3D lightClusters;
layout (set = 7, binding = 1, r16ui) uniform readonly uimage1D lightIndices;



// TODO():
vec3 CookTorrBRDFPoint(PointLight light, inout GBuffer gbuffer, inout PBRInfo pbrInfo)
{
  vec3 L = light.position.xyz - gbuffer.pos;
  float distance = length(L);
  // Return if range is less than the distance between light and fragment.
  if (light.range < distance) { return vec3(0.0); }

  vec3 color = vec3(0.0);
  float falloff = (distance / light.range);
  float attenuation = light.intensity - (light.intensity * falloff);
  vec3 nL = normalize(L);
  
  vec3 H = normalize(pbrInfo.V + nL);
  
  float NoL = clamp(dot(pbrInfo.N, nL), 0.001, 1.0);
  float NoH = clamp(dot(pbrInfo.N, H), 0.0, 1.0);
  float VoH = clamp(dot(pbrInfo.V, H), 0.0, 1.0);

  vec3 radiance = light.color.xyz * attenuation;
  
  if (NoL > 0.0) {
    float D = DGGX(NoH, gbuffer.roughness);
    float G = GSchlickSmithGGX(NoL, pbrInfo.NoV, gbuffer.roughness);  
    vec3 F = FSchlick(VoH, pbrInfo.F0);
    
    vec3 kS = F;
    vec3 kD = vec3(1.0) - kS;
    kD *= 1.0 - gbuffer.metallic;
  
    color += (LambertDiffuse(kD, gbuffer.albedo) + BRDF(D, F, G, NoL, pbrInfo.NoV)) * radiance * NoL;
  }
  return color;
}


// TODO():
vec3 CookTorrBRDFDirectional(DirectionLight light, inout GBuffer gbuffer, inout PBRInfo pbrInfo)
{
  vec3 color = vec3(0.0);
  vec3 L = -(light.direction.xyz);
  vec3 radiance = light.color.xyz * light.intensity;
  vec3 nL = normalize(L);
  
  vec3 H = normalize(pbrInfo.V + nL);
  
  float NoL = clamp(dot(pbrInfo.N, nL), 0.001, 1.0);
  float NoH = clamp(dot(pbrInfo.N, H), 0.0, 1.0);
  float VoH = clamp(dot(pbrInfo.V, H), 0.0, 1.0);
  
  if (NoL > 0.0) {
    float D = DGGX(NoH, gbuffer.roughness);
    float G = GSchlickSmithGGX(NoL, pbrInfo.NoV, gbuffer.roughness);  
    vec3 F = FSchlick(VoH, pbrInfo.F0);
    vec3 kS = F;
    vec3 kD = vec3(1.0) - kS;
    kD *= 1.0 - gbuffer.metallic;
    color += (LambertDiffuse(kD, gbuffer.albedo) + BRDF(D, F, G, NoL, pbrInfo.NoV)) * NoL;
  }
  return color * radiance;
}


// TODO(): This will eventually be integrated into Directional, as we will need to 
// support more shadow maps (using a Sampler2DArray.)
vec3 CookTorrBRDFPrimary(DirectionLight light, inout GBuffer gbuffer, inout PBRInfo pbrInfo)
{
  vec3 color = vec3(0.0);
  vec3 L = -(light.direction.xyz);
  vec3 radiance = light.color.xyz * light.intensity;
  vec3 nL = normalize(L);
  
  vec3 H = normalize(pbrInfo.V + nL);
  
  float NoL = clamp(dot(pbrInfo.N, nL), 0.001, 1.0);
  float NoH = clamp(dot(pbrInfo.N, H), 0.0, 1.0);
  float VoH = clamp(dot(pbrInfo.V, H), 0.0, 1.0);
  
  if (NoL > 0.0) {
    float D = DGGX(NoH, gbuffer.roughness);
    float G = GSchlickSmithGGX(NoL, pbrInfo.NoV, gbuffer.roughness);  
    vec3 F = FSchlick(VoH, pbrInfo.F0);
    vec3 kS = F;
    vec3 kD = vec3(1.0) - kS;
    kD *= 1.0 - gbuffer.metallic;
    
    vec4 staticShadowClip = staticLightSpace.lightSpace.viewProj * vec4(gbuffer.pos, 1.0);
    float staticShadowFactor = ((staticLightSpace.lightSpace.shadowTechnique.x < 1) ? FilterPCF(staticShadowMap, staticShadowClip) : PCSS(staticShadowMap, staticLightSpace.lightSpace, staticShadowClip));
    float shadowFactor = staticShadowFactor;
    if (gWorldBuffer.enableShadows >= 1) {
      vec4 shadowClip = dynamicLightSpace.lightSpace.viewProj * vec4(gbuffer.pos, 1.0);
      float dynamicShadowFactor = ((dynamicLightSpace.lightSpace.shadowTechnique.x < 1) ? FilterPCF(dynamicShadowMap, shadowClip) : PCSS(dynamicShadowMap, dynamicLightSpace.lightSpace, shadowClip));
      shadowFactor = min(dynamicShadowFactor, staticShadowFactor);
    }
    
    color = (LambertDiffuse(kD, gbuffer.albedo) + BRDF(D, F, G, NoL, pbrInfo.NoV)) * radiance * shadowFactor * NoL;
  }
  return color;
}


layout (local_size_x = LOCAL_SIZE, local_size_y = LOCAL_SIZE, local_size_z = 1) in;
void main()
{
  ivec2 uv = ivec2(gl_GlobalInvocationID.xy);
  vec2 texCoord = vec2(uv.xy / gWorldBuffer.screenSize.xy);
  GBuffer gbuffer = ReadGBuffer(uv, inRt0, inRt1, inRt2, inRt3, inDepth);
  
  if (isnan(gbuffer.pos.x)) return; 
  
  vec3 N = normalize(gbuffer.normal);
  vec3 V = normalize(gWorldBuffer.cameraPos.xyz - gbuffer.pos);
  vec3 F0 = vec3(0.04);
  F0 = mix(F0, gbuffer.albedo, gbuffer.metallic);
  float NoV = clamp(abs(dot(N, V)), 0.001, 1.0);
  vec3 R = -normalize(V - 2.0 * dot(N, V) * N);

  
  PBRInfo pbrInfo;
  pbrInfo.albedo = gbuffer.albedo;
  pbrInfo.F0 = F0;
  pbrInfo.NoV = NoV;
  pbrInfo.N = N;
  pbrInfo.V = V;
  pbrInfo.roughness = gbuffer.roughness;
  
  // Brute force lights for now.
  // TODO(): Map light probes in the future, to produce environment ambient instead.
  vec3 outColor = GetIBLContribution(pbrInfo, R, brdfLut, specMap, specMap);//vec3(0.0);
  
#if defined(LOCAL_REFLECTIONS)
#endif

  if (gLightBuffer.primaryLight.enable > 0) {
    DirectionLight light = gLightBuffer.primaryLight;
    vec3 ambient = light.ambient.rgb * gbuffer.albedo;
    outColor += ambient;
    outColor += CookTorrBRDFPrimary(light, gbuffer, pbrInfo); 
    outColor = max(outColor, ambient);
  }
  
  for (int i = 0; i < MAX_DIRECTION_LIGHTS; ++i) {
    DirectionLight light = gLightBuffer.directionLights[i];
    if (light.enable <= 0) { continue; }
    outColor += light.ambient.rgb * gbuffer.albedo;
    outColor += CookTorrBRDFDirectional(light, gbuffer, pbrInfo);
  }
  
  for (int i = 0; i < MAX_POINT_LIGHTS; ++i) {
    PointLight light = gLightBuffer.pointLights[i];
    if (light.enable <= 0) { continue; }
    outColor += CookTorrBRDFPoint(light, gbuffer, pbrInfo);
  }
  
  outColor = gbuffer.emissionStrength * 20.0 * gbuffer.emission + (outColor * gbuffer.ao);
  vec4 color = vec4(outColor, 1.0);
  
  imageStore(outResult, uv, color);
  
  vec3 glow = outColor.rgb - length(gWorldBuffer.cameraPos.xyz - gbuffer.pos) * 0.2;
  glow = max(glow, vec3(0.0));
  glow = glow * 0.02;
  glow = clamp(glow, vec3(0.0), vec3(1.0));
  imageStore(outBright, uv, vec4(glow, 1.0));
}




